# 최단 경로 알고리즘 (Shortest Path)

## 목차
- [다익스트라 알고리즘](#다익스트라-알고리즘-dijkstras-algorithm)
  - [개념](#개념)
  - [특징](#특징)
  - [동작 원리](#동작-원리)
  - [구현 세부사항](#구현-세부사항)
    - [MinHeap 클래스](#minheap-클래스)
    - [상향 조정 (heapifyUp)](#상향-조정-heapifyup)
    - [하향 조정 (heapifyDown)](#하향-조정-heapifydown)
    - [pop() 연산 상세 설명](#pop-연산-상세-설명)
    - [형제 노드 간 크기 관계](#형제-노드-간-크기-관계)
  - [사용 예시](#사용-예시)
  - [다익스트라 알고리즘 동작 예시](#다익스트라-알고리즘-동작-예시)
  - [장점](#장점)
  - [단점](#단점)
  - [실행 방법](#실행-방법)

---

## 다익스트라 알고리즘 (Dijkstra's Algorithm)

### 개념
다익스트라 알고리즘은 그래프에서 한 노드에서 다른 모든 노드까지의 최단 거리를 구하는 알고리즘입니다. 음수 가중치가 없는 그래프에서 사용할 수 있습니다.

### 특징
- **시간 복잡도**: O((V + E) log V) - V는 노드 수, E는 간선 수
- **공간 복잡도**: O(V)
- **그리디 알고리즘**: 매 단계에서 현재까지 알려진 최단 거리의 노드를 선택
- **우선순위 큐**: 최소 힙을 사용하여 효율적으로 최소 거리 노드를 선택

### 동작 원리
1. 시작 노드의 거리를 0으로, 나머지 노드의 거리를 무한대로 초기화
2. 우선순위 큐에 시작 노드를 삽입
3. 큐에서 가장 거리가 짧은 노드를 꺼냄
4. 해당 노드와 연결된 이웃 노드들의 거리를 업데이트
5. 더 짧은 경로가 발견되면 큐에 삽입
6. 큐가 빌 때까지 반복

### 구현 세부사항

#### MinHeap 클래스
Python의 `heapq`와 유사한 기능을 제공하는 최소 힙 구현입니다.

**힙이란?**
- 완전 이진 트리 기반의 자료구조
- 배열로 구현하며, 인덱스 i의 노드에 대해:
  - 부모: `Math.floor((i-1)/2)`
  - 왼쪽 자식: `2*i + 1`
  - 오른쪽 자식: `2*i + 2`

**최소 힙의 특성:**
- 부모 노드는 항상 자식 노드보다 작거나 같음
- 루트 노드(인덱스 0)가 항상 최소값
- **중요**: 왼쪽 자식과 오른쪽 자식 간의 크기는 상관없음!

**주요 메서드:**
- `push(priority, value)`: 요소 추가 - O(log n)
- `pop()`: 최소값 제거 및 반환 - O(log n)
- `isEmpty()`: 힙이 비었는지 확인 - O(1)

#### 상향 조정 (heapifyUp)
새로운 요소를 힙의 맨 끝에 추가한 후, 힙 속성을 복구하는 과정입니다.

**동작 과정:**
1. 새로 추가된 요소(맨 끝 인덱스)부터 시작
2. 부모 노드와 비교
3. 현재 노드가 부모보다 작으면 교환
4. 루트에 도달하거나 부모보다 크거나 같을 때까지 반복

**예시:**
```
[1, 5, 3]에 0을 추가
→ [1, 5, 3, 0]
→ 0이 부모(5)보다 작으므로 교환 → [1, 0, 3, 5]
→ 0이 부모(1)보다 작으므로 교환 → [0, 1, 3, 5]
```

#### 하향 조정 (heapifyDown)
루트 노드를 제거한 후, 마지막 요소를 루트로 옮기고 힙 속성을 복구하는 과정입니다.

**동작 과정:**
1. 루트(인덱스 0)부터 시작
2. 왼쪽 자식과 오른쪽 자식 중 가장 작은 값 찾기
3. 현재 노드가 가장 작은 자식보다 크면 교환
4. 리프 노드에 도달하거나 자식들보다 작거나 같을 때까지 반복

**예시:**
```
[1, 3, 2, 7, 5]에서 1(루트)을 제거하고 5를 루트로 이동
→ [5, 3, 2, 7]
→ 5가 자식(2, 3) 중 최소값(2)보다 크므로 교환 → [2, 3, 5, 7]
→ 5가 자식(7)보다 작으므로 종료
```

#### pop() 연산 상세 설명
pop() 연산이 헷갈릴 수 있으므로 단계별로 설명합니다.

**핵심 포인트:**
- 제거하려는 것: `heap[0]` (첫 번째 요소 = 최소값)
- 하지만 첫 번째를 바로 제거하면 배열에 구멍이 생김
- 그래서 "마지막 요소"를 "첫 번째 위치"로 옮기고, 배열 크기를 줄임

**단계별 동작: `[1, 3, 2, 7]`에서 pop()**
```typescript
1. root = heap[0]           // 1을 임시 저장 (반환할 값)
2. heap.pop()               // 마지막 7을 제거, 배열 → [1, 3, 2]
3. heap[0] = 7              // 첫 번째에 7을 넣음 → [7, 3, 2]
4. heapifyDown()            // 7을 올바른 위치로 → [2, 3, 7]
5. return root              // 1 반환
```

**왜 이렇게 하나?**
- 배열 중간 제거: O(n) - 모든 요소를 한 칸씩 이동
- 배열 마지막 제거: O(1) - 크기만 줄이면 됨
- 재정렬(heapifyDown): O(log n)
- **총 O(log n)**으로 효율적!

**중요:** `heap[0]` (첫 번째 요소)와 `heap.pop()` (마지막 요소)은 서로 다른 요소입니다!

#### 형제 노드 간 크기 관계
많은 사람들이 궁금해하는 부분입니다.

**질문: 왼쪽 자식이 오른쪽 자식보다 커도 되나요?**

**답변: 네! 완전히 괜찮습니다!**

**힙의 규칙:**
1. ✅ 부모는 자식들보다 작아야 함 (최소 힙)
2. ✅ 왼쪽 자식과 오른쪽 자식 간의 크기는 상관없음!

**예시 1: `[1, 2, 5]` - 왼쪽 < 오른쪽**
```
    1
   / \
  2   5
```
✓ 유효한 힙

**예시 2: `[1, 5, 2]` - 왼쪽 > 오른쪽**
```
    1
   / \
  5   2
```
✓ 유효한 힙 (왼쪽이 오른쪽보다 크지만 괜찮음!)

**예시 3: `[3, 7, 5]` - 왼쪽 > 오른쪽**
```
    3
   / \
  7   5
```
✓ 유효한 힙

**핵심:**
- 힙은 "부모-자식" 관계만 중요하고, "형제" 간 관계는 무시!
- 이것이 힙이 "부분 정렬" 자료구조인 이유
- 완전 정렬이 아니라서 O(log n)에 삽입/삭제 가능!

#### dijkstra 함수
- 그래프와 시작 노드를 입력받음
- 각 노드까지의 최단 거리를 담은 객체를 반환
- visited Set을 사용하여 이미 처리된 노드를 추적
- MinHeap을 우선순위 큐로 활용하여 항상 최단 거리 노드를 먼저 처리

### 사용 예시
```typescript
const graph = {
    'A': { 'B': 2, 'C': 5 },
    'B': { 'A': 2, 'C': 3, 'D': 1 },
    'C': { 'A': 5, 'B': 3, 'D': 2 },
    'D': { 'B': 1, 'C': 2 }
};

const distances = dijkstra(graph, 'A');
// { A: 0, B: 2, C: 5, D: 3 }
```

### 다익스트라 알고리즘 동작 예시

위 그래프에서 A를 시작점으로 했을 때의 단계별 동작:

**초기 상태:**
```
거리: { A: 0, B: ∞, C: ∞, D: ∞ }
우선순위 큐: [(0, A)]
방문: []
```

**1단계: A 노드 처리**
- 큐에서 (0, A) 꺼냄
- A의 이웃: B(거리 2), C(거리 5)
- 거리 업데이트: B = 0+2 = 2, C = 0+5 = 5
- 큐에 추가: [(2, B), (5, C)]

**2단계: B 노드 처리**
- 큐에서 (2, B) 꺼냄 (최소값)
- B의 이웃: A(거리 2), C(거리 3), D(거리 1)
- A는 이미 방문, C = min(5, 2+3) = 5 (변경 없음)
- D = 2+1 = 3으로 업데이트
- 큐 상태: [(3, D), (5, C)]

**3단계: D 노드 처리**
- 큐에서 (3, D) 꺼냄 (최소값)
- D의 이웃: B(거리 1), C(거리 2)
- B는 이미 방문, C = min(5, 3+2) = 5 (변경 없음)
- 큐 상태: [(5, C)]

**4단계: C 노드 처리**
- 큐에서 (5, C) 꺼냄
- 모든 노드 방문 완료

**최종 결과:**
```
{ A: 0, B: 2, C: 5, D: 3 }
```

**최단 경로:**
- A → A: 0 (시작점)
- A → B: 2 (A → B)
- A → C: 5 (A → C)
- A → D: 3 (A → B → D)

### 장점
- 음수 가중치가 없는 그래프에서 정확한 최단 경로를 찾음
- 한 노드에서 모든 노드까지의 최단 거리를 한 번에 계산
- 우선순위 큐를 사용하여 효율적

### 단점
- 음수 가중치를 가진 그래프에서는 사용 불가 (벨만-포드 알고리즘 사용)
- 모든 노드 간의 최단 경로를 구하려면 각 노드마다 실행 필요 (플로이드-워셜 알고리즘 사용)

### 실행 방법

**코드 실행:**
```bash
npx ts-node Ch2/ShortestPath/Dijkstra.ts
```

**실행 시 출력되는 내용:**
1. 다익스트라 알고리즘 테스트 결과
2. MinHeap 동작 확인
3. pop() 연산의 단계별 설명
4. 두 번째 pop() 연산 예제
5. 왼쪽/오른쪽 자식의 크기 관계 설명

코드에는 실제 동작을 확인할 수 있는 다양한 예제가 포함되어 있습니다!

---

## 핵심 요약

### 힙의 3가지 핵심
1. **부모는 자식보다 작다** (최소 힙의 경우)
2. **형제끼리의 크기는 상관없다** (왼쪽 vs 오른쪽)
3. **배열로 구현하되 트리처럼 동작한다**

### pop() 연산의 핵심
```
heap[0] (첫 번째) ≠ heap.pop() (마지막)
```
- 첫 번째를 저장하고
- 마지막을 제거해서 첫 번째에 넣고
- 재정렬한다

### 다익스트라의 핵심
- **그리디**: 항상 현재 최단 거리 노드를 선택
- **최소 힙**: O(log n)으로 최소값을 효율적으로 추출
- **결과**: O((V + E) log V)의 빠른 최단 경로 계산


