# 퀵 정렬 (Quick Sort)

이 폴더는 퀵 정렬 알고리즘의 구현을 포함합니다.

## 파일 목록

### QuickSort.ts
퀵 정렬 알고리즘의 구현과 테스트 코드입니다.

#### 구현된 함수들:

- **quickSort(arr)**: 퀵 정렬 알고리즘
- **arr**: 테스트용 랜덤 배열

## 퀵 정렬 알고리즘

### 알고리즘 설명
퀵 정렬은 **분할 정복(Divide and Conquer)** 방식의 정렬 알고리즘입니다. 피벗(pivot)을 선택하여 배열을 두 부분으로 나누고, 각 부분을 재귀적으로 정렬합니다.

### 동작 원리

1. **피벗 선택**: 배열의 중간 요소를 피벗으로 선택
2. **분할**: 피벗보다 작은 요소들은 왼쪽, 큰 요소들은 오른쪽으로 분할
3. **재귀 정렬**: 왼쪽과 오른쪽 부분을 각각 재귀적으로 정렬
4. **병합**: 정렬된 왼쪽 부분 + 피벗 + 정렬된 오른쪽 부분

### 구현
```typescript
export const quickSort = (arr: number[]): number[] => {
  if (arr.length <= 1) return arr;

  const pivot = arr[Math.floor(arr.length / 2)];
  const left = arr.filter((num) => num < pivot);
  const right = arr.filter((num) => num > pivot);
  return [...quickSort(left), pivot, ...quickSort(right)];
};
```

### 코드 분석

#### 1. 기저 케이스
```typescript
if (arr.length <= 1) return arr;
```
- 배열의 길이가 1 이하일 때는 이미 정렬된 상태로 간주

#### 2. 피벗 선택
```typescript
const pivot = arr[Math.floor(arr.length / 2)];
```
- 배열의 중간 인덱스 요소를 피벗으로 선택
- `Math.floor(arr.length / 2)`: 중간 인덱스 계산

#### 3. 분할
```typescript
const left = arr.filter((num) => num < pivot);
const right = arr.filter((num) => num > pivot);
```
- `filter()` 메서드를 사용하여 피벗보다 작은/큰 요소들을 분리
- 피벗과 같은 값은 제외 (중복 처리)

#### 4. 재귀 및 병합
```typescript
return [...quickSort(left), pivot, ...quickSort(right)];
```
- 스프레드 연산자(`...`)를 사용하여 배열 병합
- 왼쪽 부분과 오른쪽 부분을 각각 재귀적으로 정렬

### 실행 과정 예시

```
원본 배열: [64, 34, 25, 12, 22, 11, 90]
피벗: 12 (중간 요소)

분할:
- left: [11] (12보다 작은 요소들)
- pivot: 12
- right: [64, 34, 25, 22, 90] (12보다 큰 요소들)

재귀 호출:
- quickSort([11]) → [11]
- quickSort([64, 34, 25, 22, 90]) → [22, 25, 34, 64, 90]

최종 결과: [11, 12, 22, 25, 34, 64, 90]
```

## 퀵소트 재귀 과정 상세 분석

### 재귀 호출 스택과 분할 과정

퀵소트의 재귀 과정을 단계별로 자세히 살펴보겠습니다. 예시로 `[38, 27, 43, 3, 9, 82, 10]` 배열을 사용합니다.

#### 1단계: 최초 호출
```
quickSort([38, 27, 43, 3, 9, 82, 10])
├─ 피벗: 3 (인덱스 3)
├─ left: [] (3보다 작은 요소들 - 없음)
├─ right: [38, 27, 43, 9, 82, 10] (3보다 큰 요소들)
└─ return [...quickSort([]), 3, ...quickSort([38, 27, 43, 9, 82, 10])]
```

#### 2단계: 왼쪽 부분 처리
```
quickSort([])
├─ 길이가 0이므로 기저 케이스
└─ return []
```

#### 3단계: 오른쪽 부분 처리 (첫 번째 재귀)
```
quickSort([38, 27, 43, 9, 82, 10])
├─ 피벗: 43 (인덱스 2)
├─ left: [38, 27, 9, 10] (43보다 작은 요소들)
├─ right: [82] (43보다 큰 요소들)
└─ return [...quickSort([38, 27, 9, 10]), 43, ...quickSort([82])]
```

#### 4단계: 오른쪽 부분의 왼쪽 처리 (두 번째 재귀)
```
quickSort([38, 27, 9, 10])
├─ 피벗: 9 (인덱스 2)
├─ left: [9] (9보다 작은 요소들)
├─ right: [38, 27, 10] (9보다 큰 요소들)
└─ return [...quickSort([9]), 9, ...quickSort([38, 27, 10])]
```

#### 5단계: 더 깊은 재귀들
```
quickSort([9]) → [9] (기저 케이스)

quickSort([38, 27, 10])
├─ 피벗: 27 (인덱스 1)
├─ left: [10] (27보다 작은 요소들)
├─ right: [38] (27보다 큰 요소들)
└─ return [...quickSort([10]), 27, ...quickSort([38])]

quickSort([10]) → [10] (기저 케이스)
quickSort([38]) → [38] (기저 케이스)
```

#### 6단계: 오른쪽 부분의 오른쪽 처리
```
quickSort([82]) → [82] (기저 케이스)
```

### 재귀 호출 스택 시각화

```
스택 레벨 0: quickSort([38, 27, 43, 3, 9, 82, 10])
├─ 스택 레벨 1: quickSort([]) → [] (빈 배열)
├─ 스택 레벨 1: quickSort([38, 27, 43, 9, 82, 10])
│  ├─ 스택 레벨 2: quickSort([38, 27, 9, 10])
│  │  ├─ 스택 레벨 3: quickSort([9]) → [9]
│  │  └─ 스택 레벨 3: quickSort([38, 27, 10])
│  │     ├─ 스택 레벨 4: quickSort([10]) → [10]
│  │     └─ 스택 레벨 4: quickSort([38]) → [38]
│  │     └─ 합쳐짐: [10, 27, 38]
│  └─ 스택 레벨 2: quickSort([82]) → [82]
│  └─ 합쳐짐: [9, 10, 27, 38, 43, 82]
└─ 합쳐짐: [] + 3 + [9, 10, 27, 38, 43, 82] = [3, 9, 10, 27, 38, 43, 82]
```

### 합쳐지는 과정 (병합 단계)

각 재귀 호출이 완료되면 다음과 같이 합쳐집니다:

1. **가장 깊은 레벨에서 시작**:
   - `[9]` + `[10, 27, 38]` = `[9, 10, 27, 38]`

2. **한 단계 위로**:
   - `[9, 10, 27, 38]` + `43` + `[82]` = `[9, 10, 27, 38, 43, 82]`

3. **최상위 레벨**:
   - `[]` + `3` + `[9, 10, 27, 38, 43, 82]` = `[3, 9, 10, 27, 38, 43, 82]`

### 재귀의 핵심 원리

1. **분할**: 배열을 피벗 기준으로 두 부분으로 나눔
2. **정복**: 각 부분을 재귀적으로 정렬
3. **결합**: 정렬된 부분들을 피벗과 함께 합침

### 스택 메모리 사용

```
호출 스택:
┌─────────────────────────────────────┐
│ quickSort([38, 27, 43, 3, 9, 82, 10]) │ ← 최상위
├─────────────────────────────────────┤
│ quickSort([38, 27, 43, 9, 82, 10])    │
├─────────────────────────────────────┤
│ quickSort([38, 27, 9, 10])           │
├─────────────────────────────────────┤
│ quickSort([38, 27, 10])              │
└─────────────────────────────────────┘
```

각 재귀 호출은 독립적인 스택 프레임을 가지며, 완료되면 결과를 상위 호출자에게 반환합니다.

### 시간 복잡도

- **평균 케이스**: O(n log n)
- **최악 케이스**: O(n²) - 이미 정렬된 배열이나 모든 요소가 같은 경우
- **최선 케이스**: O(n log n) - 피벗이 항상 중간값인 경우

### 공간 복잡도

- **평균 케이스**: O(log n) - 재귀 호출 스택
- **최악 케이스**: O(n) - 불균형한 분할의 경우

### 장단점

#### 장점
1. **평균적으로 빠름**: 대부분의 경우 O(n log n) 성능
2. **제자리 정렬**: 추가 메모리 사용량이 적음
3. **캐시 친화적**: 지역성(locality)이 좋음
4. **병렬화 가능**: 분할된 부분을 병렬로 처리 가능

#### 단점
1. **불안정 정렬**: 같은 값의 상대적 순서가 바뀔 수 있음
2. **최악 케이스**: 이미 정렬된 배열에서 O(n²) 성능
3. **피벗 선택의 중요성**: 잘못된 피벗 선택 시 성능 저하

### 최적화 방안

1. **피벗 선택 개선**
   - 삼중 중간값(median-of-three) 방법
   - 랜덤 피벗 선택

2. **작은 배열 처리**
   - 작은 배열(예: 10개 이하)은 삽입 정렬 사용

3. **중복 요소 처리**
   - 피벗과 같은 요소들을 별도로 처리

### 사용법

```typescript
import { quickSort, arr } from './QuickSort';

console.log('원본 배열:', arr);
const sortedArr = quickSort(arr);
console.log('정렬된 배열:', sortedArr);
```

### 다른 정렬 알고리즘과의 비교

| 알고리즘 | 평균 시간 | 최악 시간 | 공간 복잡도 | 안정성 |
|---------|----------|----------|------------|--------|
| 퀵 정렬 | O(n log n) | O(n²) | O(log n) | 불안정 |
| 병합 정렬 | O(n log n) | O(n log n) | O(n) | 안정 |
| 힙 정렬 | O(n log n) | O(n log n) | O(1) | 불안정 |
| 삽입 정렬 | O(n²) | O(n²) | O(1) | 안정 | 