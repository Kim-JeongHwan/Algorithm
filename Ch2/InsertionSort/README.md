# 삽입 정렬 (Insertion Sort)

## 개요
삽입 정렬은 간단한 정렬 알고리즘으로, 배열의 두 번째 요소부터 시작하여 앞의 요소들과 비교하여 적절한 위치에 삽입하는 방식으로 정렬을 수행합니다.

## 알고리즘 동작 방식
1. 배열의 두 번째 요소부터 시작하여 순차적으로 검사
2. 현재 요소를 이전 요소들과 비교
3. 현재 요소보다 큰 요소들을 한 칸씩 뒤로 이동
4. 적절한 위치에 현재 요소를 삽입
5. 배열의 끝까지 반복

## 시간 복잡도
- **최선의 경우**: O(n) - 이미 정렬된 배열
- **평균의 경우**: O(n²)
- **최악의 경우**: O(n²) - 역순으로 정렬된 배열

## 공간 복잡도
- O(1) - 추가 메모리 공간이 거의 필요하지 않음

## 장점
- 구현이 간단함
- 작은 데이터셋에 효율적
- 안정 정렬 (stable sort)
- 제자리 정렬 (in-place sort)

## 단점
- 큰 데이터셋에서는 비효율적
- 시간 복잡도가 O(n²)로 높음

## 상세 동작 과정 예시

`[12, 11, 13, 5, 6]` 배열을 정렬하는 과정을 단계별로 살펴보겠습니다:

### 초기 배열: `[12, 11, 13, 5, 6]`

### 1단계: i=1, key=11 (두 번째 요소)
- **비교**: 11 < 12
- **동작**: 12를 한 칸 뒤로 이동
- **결과**: `[11, 12, 13, 5, 6]`

### 2단계: i=2, key=13 (세 번째 요소)
- **비교**: 13 > 12
- **동작**: 이동 없음
- **결과**: `[11, 12, 13, 5, 6]`

### 3단계: i=3, key=5 (네 번째 요소) - 핵심 과정

5가 첫 번째 위치까지 이동하는 과정:

**3-1. j=2, arr[2]=13과 비교**
- 13 > 5이므로 13을 한 칸 뒤로 이동
- `[11, 12, 13, 13, 6]` (arr[3] = arr[2])

**3-2. j=1, arr[1]=12와 비교**
- 12 > 5이므로 12를 한 칸 뒤로 이동
- `[11, 12, 12, 13, 6]` (arr[2] = arr[1])

**3-3. j=0, arr[0]=11과 비교**
- 11 > 5이므로 11을 한 칸 뒤로 이동
- `[11, 11, 12, 13, 6]` (arr[1] = arr[0])

**3-4. j=-1이 되므로 while 루프 종료**
- arr[j+1] = arr[0] = 5 삽입
- **최종 결과**: `[5, 11, 12, 13, 6]`

### 4단계: i=4, key=6 (다섯 번째 요소)
- **비교**: 6 < 13, 6 < 12, 6 < 11, 6 > 5
- **동작**: 13, 12, 11을 각각 한 칸씩 뒤로 이동
- **결과**: `[5, 6, 11, 12, 13]`

### 시각적 정리
```
[12, 11, 13, 5, 6]  ← 초기
[11, 12, 13, 5, 6]  ← 1단계 후
[11, 12, 13, 5, 6]  ← 2단계 후
[5, 11, 12, 13, 6]  ← 3단계 후 (5가 첫 번째로!)
[5, 6, 11, 12, 13]  ← 최종 결과
```

## 핵심 포인트

- **5가 첫 번째 위치까지 이동하는 이유**: 5보다 큰 모든 요소들(13, 12, 11)이 5보다 앞에 위치해 있었기 때문
- 삽입 정렬은 **현재 요소보다 큰 모든 요소를 한 칸씩 뒤로 밀어내고**, **적절한 위치에 삽입**하는 방식
- 5는 배열에서 가장 작은 값이므로, 모든 요소를 뒤로 밀어내고 **첫 번째 위치**에 삽입됨

## 사용 예시
```typescript
const arr: number[] = [12, 11, 13, 5, 6]
insertionSort(arr)
console.log(arr) // [5, 6, 11, 12, 13]
```

## 구현 파일
- `InsertionSort.ts`: 삽입 정렬 알고리즘 구현 